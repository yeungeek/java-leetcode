# 复杂度分析
复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半.  

## 大 O 复杂度表示法
所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正，这个规律可以用下面的公式来表示： 
<div align='center'> 
$$
T(n) = O(f(n))
$$  


大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作**渐进时间复杂度（asymptotic time complexity）**，简称**时间复杂度**。

## 时间复杂度分析
1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 复杂度量级
* 常量级 $$ O(1)$$ 
* 对数阶 $$ O(logn)$$ 
* 线性阶 $$ O(n)$$ 
* 对数线性阶 $$ O(nlogn)$$ 
* 平方阶 $$ O(n^{2})$$、立方阶$$O(n^{3})$$...k 次方阶$$O(n^{k})$$
* 指数阶$$O(2^{n})$$
* 阶橙阶$$O(n!)$$

对于刚罗列的复杂度量级，我们可以粗略地分为两类，**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个：$$O(2^{n})$$ 和 $$O(n!)$$
#### $$ O(1)$$ 
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是$$ O(1)$$ 
#### $$O(logn)$$、$$O(nlogn)$$
在采用大 O 标记复杂度的时候，可以忽略系数，即 $$O(Cf(n)) = O(f(n))$$。所以，$$O(log2n)$$ 就等于 $$O(log3n)$$。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 $$O(logn)$$。
#### $$O(m+n)$$、$$O(m*n)$$
代码的复杂度由两个数据的规模来决定

### 最好情况时间复杂度
最好情况时间复杂度（best case time complexity)，在最理想的情况下，执行这段代码的时间复杂度。
### 最坏情况时间复杂度
最坏情况时间复杂度（worst case time complexity），在最糟糕的情况下，执行这段代码的时间复杂度。
### 平均情况时间复杂度
平均情况时间复杂度（average case time complexity），平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**
### 均摊时间复杂度
均摊时间复杂度amortized time complexity），通过摊还分析得到的时间复杂度。   
大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。  
对一个数据结构进行一组连续操作中，，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

## 空间复杂度分析
空间复杂度全称就是渐进空间复杂度（asymptotic space complexity)，表示算法的存储空间与数据规模之间的增长关系。  
常见的空间复杂度 $$ O(1)$$、$$ O(n)$$、$$ O(n^{2})$$     
数据结构和算法的复杂度基本都在下面这个图中了
![](../../images/Tn.jpg)

